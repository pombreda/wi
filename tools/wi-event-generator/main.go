// Copyright 2014 Marc-Antoine Ruel. All rights reserved.
// Use of this source code is governed under the Apache License, Version 2.0
// that can be found in the LICENSE file.

// Generates editor/event_registry.go from wicore/events.go.
package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"reflect"
	"strings"
	"text/template"

	"github.com/maruel/wi/wicore"
)

func formatSource(buf []byte) ([]byte, error) {
	src, err := format.Source(buf)
	if err != nil {
		b := bytes.Buffer{}
		fmt.Printf("// ERROR: internal error: invalid Go generated: %s\n", err)
		fmt.Printf("// Compile the package to analyze the error.\n\n")
		_, _ = b.Write(buf)
		src = b.Bytes()
	}
	return src, err
}

var tmplImpl = template.Must(template.New("render").Parse(`// generated by {{.CmdLine}}; DO NOT EDIT

package editor

import (
  "errors"
  "sync"

  "github.com/maruel/wi/pkg/key"
  "github.com/maruel/wi/pkg/lang"
  "github.com/maruel/wi/wicore"
)
{{range .Events}}
type event{{.Name}} struct{
	id wicore.EventListenerID
	callback func({{.Args}}) {{.Result}}
}
{{end}}
// eventRegistry is automatically generated via wi-event-generator from the
// interface wicore.EventRegistry.
type eventRegistry struct {
  lock   sync.Mutex
  nextID wicore.EventListenerID
	deferred chan func()
{{range .Events}}
	{{.Lower}} []event{{.Name}}{{end}}
}

func makeEventRegistry() eventRegistry {
	// Reduce the odds of allocation within RegistryXXX() by using relatively
	// large buffers.
	return eventRegistry{
		deferred: make(chan func(), 2048),{{range .Events}}
		{{.Lower}}: make([]event{{.Name}}, 0, 64),{{end}}
	}
}

func (er *eventRegistry) Unregister(eventID wicore.EventListenerID) error {
  er.lock.Lock()
  defer er.lock.Unlock()
	// TODO(maruel): The buffers are never reallocated, so it's effectively a
	// memory leak.
	switch(eventID & {{.BitMask}}) { {{range .Events}}
	case {{.BitValue}}:
		for index, value := range er.{{.Lower}} {
			if value.id == eventID {
				copy(er.{{.Lower}}[index:], er.{{.Lower}}[index+1:])
				er.{{.Lower}} = er.{{.Lower}}[0 : len(er.{{.Lower}})-1]
				return nil
			}
		}{{end}}
  }
	return errors.New("trying to unregister an non existing event listener")
}{{range .Events}}

func (er *eventRegistry) Register{{.Name}}(callback func({{.Args}}) {{.Result}}) wicore.EventListenerID {
  er.lock.Lock()
  defer er.lock.Unlock()
  i := er.nextID
  er.nextID++
  er.{{.Lower}} = append(er.{{.Lower}}, event{{.Name}}{i, callback})
  return i | {{.BitValue}}
}

func (er *eventRegistry) Trigger{{.Name}}({{.Args}}) {
	er.deferred <- func() {
		items := func() []func({{.Args}}) {{.Result}} {
			er.lock.Lock()
			defer er.lock.Unlock()
			items := make([]func({{.Args}}) {{.Result}}, 0, len(er.{{.Lower}}))
			for _, item := range er.{{.Lower}} {
				items = append(items, item.callback)
			}
			return items
		}()
		for _, item := range items {
			item({{.ArgsNames}})
		}
	}
}{{end}}
`))

var tmplDecl = template.Must(template.New("render").Parse(`// generated by {{.CmdLine}}; DO NOT EDIT

package wicore

import (
  "github.com/maruel/wi/pkg/key"
  "github.com/maruel/wi/pkg/lang"
)

// EventListenerID is to be used to cancel an event listener.
type EventListenerID int

// EventRegistry permits to register callbacks that are called on events.
//
// When the callback returns false, the next registered events are not called.
//
// Warning: This interface is automatically generated.
type EventRegistry interface {
	EventsDefinition

  // Unregister unregisters a callback. Returns an error if the event was not
  // registered.
  Unregister(eventID EventListenerID) error
{{range .Events}}
  Register{{.Name}}(callback func({{.Args}}) {{.Result}}) EventListenerID{{end}}
}
`))

type Event struct {
	Name      string
	Lower     string
	Index     int
	BitValue  string
	Args      string
	ArgsNames string
	Result    string
}

type tmplData struct {
	CmdLine string
	BitMask string
	Events  []Event
}

//func extractEvents(inputFile, inputType string, impl bool, bitmask uint) []Event {
func extractEvents(impl bool, bitmask uint) ([]Event, error) {
	// TODO(maruel): Use go/parser.
	t := reflect.TypeOf((*wicore.EventsDefinition)(nil)).Elem()
	prefix := "Trigger"
	events := make([]Event, 0, t.NumMethod())
	for i := 0; i < t.NumMethod(); i++ {
		m := t.Method(i)
		if !strings.HasPrefix(m.Name, prefix) {
			return nil, fmt.Errorf("unexpected method %s", m.Name)
		}
		// That is *very* cheezy. The right way would be to use go/parser to
		// extract the argument names. For now, it's "good enough".
		argsStr := m.Type.String()[5:]
		argsStr = argsStr[:strings.LastIndex(argsStr, ")")]
		//if i := strings.LastIndex(argsStr, ")"); i != len(argsStr)-1 {
		//	return nil, fmt.Errorf("unexpected return type for method %s: %s", m.Name, m.Type)
		//}
		if !impl {
			argsStr = strings.Replace(argsStr, "wicore.", "", -1)
		}
		argsItems := strings.Split(argsStr, ", ")
		args := make([]string, 0, len(argsItems))
		argsNames := make([]string, 0, len(argsItems))
		if len(argsStr) > 0 {
			// Insert names 'a', 'b', ...
			for i, s := range argsItems {
				args = append(args, fmt.Sprintf("%c %s", i+'a', s))
				argsNames = append(argsNames, fmt.Sprintf("%c", i+'a'))
			}
		}
		name := m.Name[len(prefix):]
		lower := strings.ToLower(name[0:1]) + name[1:]
		// TODO(maruel): It creates an artificial limit of 2^23 event listener and
		// 2^8 event types on 32 bits systems.
		events = append(events, Event{
			Name:      name,
			Lower:     lower,
			Index:     len(events),
			BitValue:  fmt.Sprintf("wicore.EventListenerID(0x%x)", (len(events)+1)<<bitmask),
			Args:      strings.Join(args, ", "),
			ArgsNames: strings.Join(argsNames, ", "),
			Result:    "",
		})
	}
	return events, nil
}

//func generate(inputFile string, inputType string, impl bool) ([]byte, error) {
func generate(impl bool) ([]byte, error) {
	// TODO(maruel): Make this seamless instead of hardcoded.
	bitmask := uint(24)
	//events, err := extractEvents(inputFile, inputType, impl, bitmask)
	events, err := extractEvents(impl, bitmask)
	if err != nil {
		return nil, err
	}
	d := tmplData{
		// Skip os.Args[0]Â since it may point into $TMP.
		CmdLine: "go run ../tools/wi-event-generator/main.go " + strings.Join(os.Args[1:], " "),
		BitMask: fmt.Sprintf("wicore.EventListenerID(0x%x)", ((1<<32)-1)-((1<<bitmask)-1)),
		Events:  events,
	}
	out := bytes.Buffer{}
	tmpl := tmplDecl
	if impl {
		tmpl = tmplImpl
	}
	if err := tmpl.Execute(&out, d); err != nil {
		return nil, fmt.Errorf("failed to generate go code: %s", err)
	}
	return out.Bytes(), nil
}

func mainImpl() error {
	// TODO(maruel): Use go/parser.
	//inputFile := flag.String("decl", "", "Declaration file, defaults to the source file")
	//inputType := flag.String("type", "", "Type to implement")
	impl := flag.Bool("impl", false, "Generates the implementation, otherwise it generates the interface")
	outputFile := flag.String("output", "", "Output file")
	flag.Parse()

	if len(flag.Args()) != 0 {
		return fmt.Errorf("unexpected argument: %s", flag.Args())
	}
	//if len(*inputFile) == 0 {
	//	*inputFile = flag.Args()[0]
	//}
	//if len(*inputType) == 0 {
	//	return errors.New("-type is required")
	//}
	if len(*outputFile) == 0 {
		return errors.New("-output is required")
	}
	//src, err := generate(*inputFile, *inputType, *impl)
	src, err := generate(*impl)
	if err != nil {
		return err
	}
	src, err = formatSource(src)
	err2 := ioutil.WriteFile(*outputFile, src, 0644)
	if err != nil {
		return err
	}
	return err2
}

func main() {
	if err := mainImpl(); err != nil {
		fmt.Fprintf(os.Stderr, "wi-event-generator: %s.\n", err)
		os.Exit(1)
	}
}
