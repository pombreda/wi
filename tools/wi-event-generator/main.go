// Copyright 2014 Marc-Antoine Ruel. All rights reserved.
// Use of this source code is governed under the Apache License, Version 2.0
// that can be found in the LICENSE file.

// Generates editor/event_registry.go from wicore/events.go.
package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"sort"
	"strings"
	"text/template"
)

func formatSource(buf []byte) ([]byte, error) {
	src, err := format.Source(buf)
	if err != nil {
		b := bytes.Buffer{}
		fmt.Printf("// ERROR: internal error: invalid Go generated: %s\n", err)
		fmt.Printf("// Compile the package to analyze the error.\n\n")
		_, _ = b.Write(buf)
		src = b.Bytes()
	}
	return src, err
}

var tmplImpl = template.Must(template.New("render").Parse(`// generated by {{.CmdLine}}; DO NOT EDIT

package wicore

import (
  "errors"
  "sync"

  "github.com/maruel/wi/wicore/key"
  "github.com/maruel/wi/wicore/lang"
)
{{range .Events}}
type listener{{.Name}} struct{
	id       int
	callback func({{.ParamsAsString}})
}
{{end}}
// eventRegistry is automatically generated via wi-event-generator from the
// interface EventRegistry. It completely implemented EventRegistry.
type eventRegistry struct {
  lock     sync.Mutex
  nextID   int
	deferred chan<- func()
{{range .Events}}
	{{.Lower}} []listener{{.Name}}{{end}}
}

func MakeEventRegistry() (EventRegistry, chan func()) {
	// Reduce the odds of allocation within RegistryXXX() by using relatively
	// large buffers.
	c := make(chan func(), 2048)
	e := &eventRegistry{
		deferred: c,{{range .Events}}
		{{.Lower}}: make([]listener{{.Name}}, 0, 64),{{end}}
	}
	return e, c
}

func (er *eventRegistry) unregister(eventID int) {
  er.lock.Lock()
  defer er.lock.Unlock()
	// TODO(maruel): The buffers are never reallocated, so it's effectively a
	// memory leak.
	switch(eventID & {{.BitMask}}) { {{range .Events}}
	case {{.BitValue}}:
		for index, value := range er.{{.Lower}} {
			if value.id == eventID {
				copy(er.{{.Lower}}[index:], er.{{.Lower}}[index+1:])
				er.{{.Lower}} = er.{{.Lower}}[0 : len(er.{{.Lower}})-1]
				return
			}
		}{{end}}
  }
}{{range .Events}}

func (er *eventRegistry) Register{{.Name}}(callback func({{.ParamsAsString}})) EventListener {
  er.lock.Lock()
  defer er.lock.Unlock()
  i := er.nextID
  er.nextID++
  er.{{.Lower}} = append(er.{{.Lower}}, listener{{.Name}}{i, callback})
  return &eventListener{er, i | {{.BitValue}}}
}

func (er *eventRegistry) Trigger{{.Name}}({{.ParamsAsString}}) {
	er.deferred <- func() {
		items := func() []func({{.ParamsAsString}}) {
			er.lock.Lock()
			defer er.lock.Unlock()
			items := make([]func({{.ParamsAsString}}), 0, len(er.{{.Lower}}))
			for _, item := range er.{{.Lower}} {
				items = append(items, item.callback)
			}
			return items
		}()
		for _, item := range items {
			item({{.ParamsNames}})
		}
	}
}{{end}}

type unregister interface {
  unregister(id int)
}

type eventListener struct {
	unregister unregister
	id int
}

func (e *eventListener) Close() error {
	if e.id == 0 {
		return errors.New("EventListener already closed")
	}
	e.unregister.unregister(e.id)
	e.id = 0
	return nil
}
`))

var tmplDecl = template.Must(template.New("render").Parse(`// generated by {{.CmdLine}}; DO NOT EDIT

package wicore

import (
	"io"

  "github.com/maruel/wi/wicore/key"
  "github.com/maruel/wi/wicore/lang"
)

// EventListener is to be used to cancel an event listener.
type EventListener interface {
	io.Closer
}

// NumberEvents is the number of known events.
const NumberEvents = {{len .Events}}

// EventRegistry permits to register callbacks that are called on events.
//
// When the callback returns false, the next registered events are not called.
//
// Warning: This interface is automatically generated.
type EventRegistry interface {
	EventsDefinition

{{range .Events}}
  Register{{.Name}}(callback func({{.ParamsAsString}})) EventListener{{end}}
}
`))

type Event struct {
	Name           string
	Lower          string
	Index          int
	BitValue       string
	ParamsAsString string // "a int, b string"
	ParamsNames    string // "a, b"
}

type tmplData struct {
	CmdLine string
	BitMask string
	Events  []Event
}

// Parser code.

type Arg struct {
	Name string
	Type string
}

// Method is a simplification of ast.FuncType using only strings.
type Method struct {
	Name    string
	Params  []Arg
	Results []Arg
}

// findType finds a file level type declaration and returns it if found.
func findType(f *ast.File, inputType string) *ast.TypeSpec {
	// Look at all file level declarations.
	for _, decl := range f.Decls {
		y, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		// Search for a type specification.
		for _, s := range y.Specs {
			t, ok := s.(*ast.TypeSpec)
			if !ok {
				continue
			}
			if inputType != t.Name.Name {
				continue
			}
			return t
		}
	}
	return nil
}

// processFieldList processes params or results of a method.
func processFieldList(list *ast.FieldList) ([]Arg, error) {
	if list == nil || len(list.List) == 0 {
		return []Arg{}, nil
	}
	out := make([]Arg, 0, len(list.List))
	for _, param := range list.List {
		typeName := ""
		selector, ok := param.Type.(*ast.SelectorExpr)
		if ok {
			ident, ok := selector.X.(*ast.Ident)
			if !ok {
				return out, errors.New("failed to process field")
			}
			typeName = ident.Name + "." + selector.Sel.Name
		} else {
			ident, ok := param.Type.(*ast.Ident)
			if !ok {
				return out, errors.New("failed to process field")
			}
			typeName = ident.Name
		}
		for _, name := range param.Names {
			arg := Arg{
				Name: name.Name,
				Type: typeName,
			}
			out = append(out, arg)
		}
	}
	return out, nil
}

// enumInterface enumerates all the methods of an interface.
func enumInterface(t *ast.TypeSpec) ([]Method, error) {
	typeName := t.Name.Name
	i, ok := t.Type.(*ast.InterfaceType)
	if !ok {
		return nil, fmt.Errorf("expected %s to be an interface", typeName)
	}
	out := make([]Method, 0, len(i.Methods.List))
	for _, m := range i.Methods.List {
		methodName := m.Names[0].Name
		methodFunc, ok := m.Type.(*ast.FuncType)
		if !ok {
			return out, fmt.Errorf("expected %s.%s to be a method", typeName, methodName)
		}
		params, err := processFieldList(methodFunc.Params)
		if err != nil {
			return out, fmt.Errorf("%s.%s: params %s", i, typeName, methodName, err)
		}
		results, err := processFieldList(methodFunc.Results)
		if err != nil {
			return out, fmt.Errorf("%s.%s: results %s", i, typeName, methodName, err)
		}
		method := Method{
			Name:    methodName,
			Params:  params,
			Results: results,
		}
		out = append(out, method)
	}
	return out, nil
}

// Generation code.

func extractEvents(inputFile, inputType string, impl bool, bitmask uint) ([]Event, error) {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, inputFile, nil, 0)
	if err != nil {
		return nil, err
	}
	prefix := "Trigger"
	events := []Event{}
	inputT := findType(f, inputType)
	if inputT == nil {
		return nil, fmt.Errorf("failed to find type %s", inputType)
	}
	methods, err := enumInterface(inputT)
	if err != nil {
		return nil, err
	}
	methodNames := make([]string, len(methods))
	for i, m := range methods {
		methodNames[i] = m.Name
	}
	if !sort.StringsAreSorted(methodNames) {
		return nil, fmt.Errorf("methods of %s must be sorted by name", inputType)
	}
	for _, method := range methods {
		if !strings.HasPrefix(method.Name, prefix) {
			return nil, fmt.Errorf("method %s.%s doesn't have prefix %s", inputType, method.Name, prefix)
		}
		if len(method.Results) != 0 {
			return nil, fmt.Errorf("unexpected result on method %s.%s", inputType, method.Name)
		}
		name := method.Name[len(prefix):]
		lower := strings.ToLower(name[0:1]) + name[1:]
		names := make([]string, len(method.Params))
		full := make([]string, len(method.Params))
		for i, arg := range method.Params {
			if len(arg.Name) == 0 {
				return nil, fmt.Errorf("argument %d must be named on method %s.%s", i, inputType, method.Name)
			}
			names[i] = arg.Name
			full[i] = fmt.Sprintf("%s %s", arg.Name, arg.Type)
		}
		// TODO(maruel): It creates an artificial limit of 2^23 event listener and
		// 2^8 event types on 32 bits systems.
		events = append(events, Event{
			Name:           name,
			Lower:          lower,
			Index:          len(events),
			BitValue:       fmt.Sprintf("0x%x", (len(events)+1)<<bitmask),
			ParamsAsString: strings.Join(full, ", "),
			ParamsNames:    strings.Join(names, ", "),
		})
	}
	return events, nil
}

func generate(inputFile string, inputType string, impl bool) ([]byte, error) {
	// TODO(maruel): Make the bitmask seamless instead of hardcoded.
	bitmask := uint(24)
	events, err := extractEvents(inputFile, inputType, impl, bitmask)
	if err != nil {
		return nil, err
	}
	d := tmplData{
		// Skip os.Args[0]Â since it may point into $TMP.
		CmdLine: "go run ../tools/wi-event-generator/main.go " + strings.Join(os.Args[1:], " "),
		BitMask: fmt.Sprintf("0x%x", ((1<<32)-1)-((1<<bitmask)-1)),
		Events:  events,
	}
	out := bytes.Buffer{}
	tmpl := tmplDecl
	if impl {
		tmpl = tmplImpl
	}
	if err := tmpl.Execute(&out, d); err != nil {
		return nil, fmt.Errorf("failed to generate go code: %s", err)
	}
	return out.Bytes(), nil
}

func mainImpl() error {
	impl := flag.Bool("impl", false, "Generates the implementation, otherwise it generates the interface")
	outputFile := flag.String("output", "", "Output file")
	flag.Parse()

	if len(flag.Args()) != 0 {
		return fmt.Errorf("unexpected argument: %s", flag.Args())
	}
	if len(*outputFile) == 0 {
		return errors.New("-output is required")
	}
	src, err := generate("interfaces.go", "EventsDefinition", *impl)
	if err != nil {
		return err
	}
	src, err = formatSource(src)
	err2 := ioutil.WriteFile(*outputFile, src, 0644)
	if err != nil {
		return err
	}
	return err2
}

func main() {
	if err := mainImpl(); err != nil {
		fmt.Fprintf(os.Stderr, "wi-event-generator: %s.\n", err)
		os.Exit(1)
	}
}
