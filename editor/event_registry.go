// generated by wi-event-generator; DO NOT EDIT

package editor

import (
	"errors"
	"sync"

	"github.com/maruel/wi/pkg/key"
	"github.com/maruel/wi/wicore"
)

type eventDocumentCreated struct {
	id       wicore.EventID
	callback func(a wicore.Document)
}

type eventDocumentCursorMoved struct {
	id       wicore.EventID
	callback func(a wicore.Document)
}

type eventTerminalKeyPressed struct {
	id       wicore.EventID
	callback func(a key.Press)
}

type eventTerminalResized struct {
	id       wicore.EventID
	callback func()
}

type eventViewCreated struct {
	id       wicore.EventID
	callback func(a wicore.View)
}

type eventWindowCreated struct {
	id       wicore.EventID
	callback func(a wicore.Window)
}

type eventWindowResized struct {
	id       wicore.EventID
	callback func(a wicore.Window)
}

type eventRegistry struct {
	lock   sync.Mutex
	nextID wicore.EventID

	documentCreated     []eventDocumentCreated
	documentCursorMoved []eventDocumentCursorMoved
	terminalKeyPressed  []eventTerminalKeyPressed
	terminalResized     []eventTerminalResized
	viewCreated         []eventViewCreated
	windowCreated       []eventWindowCreated
	windowResized       []eventWindowResized
}

func (er *eventRegistry) Unregister(eventID wicore.EventID) error {
	er.lock.Lock()
	defer er.lock.Unlock()
	for index, value := range er.documentCreated {
		if value.id == eventID {
			copy(er.documentCreated[index:], er.documentCreated[index+1:])
			// TODO(maruel): It's a memory leak.
			er.documentCreated = er.documentCreated[0 : len(er.documentCreated)-1]
			return nil
		}
	}
	for index, value := range er.documentCursorMoved {
		if value.id == eventID {
			copy(er.documentCursorMoved[index:], er.documentCursorMoved[index+1:])
			// TODO(maruel): It's a memory leak.
			er.documentCursorMoved = er.documentCursorMoved[0 : len(er.documentCursorMoved)-1]
			return nil
		}
	}
	for index, value := range er.terminalKeyPressed {
		if value.id == eventID {
			copy(er.terminalKeyPressed[index:], er.terminalKeyPressed[index+1:])
			// TODO(maruel): It's a memory leak.
			er.terminalKeyPressed = er.terminalKeyPressed[0 : len(er.terminalKeyPressed)-1]
			return nil
		}
	}
	for index, value := range er.terminalResized {
		if value.id == eventID {
			copy(er.terminalResized[index:], er.terminalResized[index+1:])
			// TODO(maruel): It's a memory leak.
			er.terminalResized = er.terminalResized[0 : len(er.terminalResized)-1]
			return nil
		}
	}
	for index, value := range er.viewCreated {
		if value.id == eventID {
			copy(er.viewCreated[index:], er.viewCreated[index+1:])
			// TODO(maruel): It's a memory leak.
			er.viewCreated = er.viewCreated[0 : len(er.viewCreated)-1]
			return nil
		}
	}
	for index, value := range er.windowCreated {
		if value.id == eventID {
			copy(er.windowCreated[index:], er.windowCreated[index+1:])
			// TODO(maruel): It's a memory leak.
			er.windowCreated = er.windowCreated[0 : len(er.windowCreated)-1]
			return nil
		}
	}
	for index, value := range er.windowResized {
		if value.id == eventID {
			copy(er.windowResized[index:], er.windowResized[index+1:])
			// TODO(maruel): It's a memory leak.
			er.windowResized = er.windowResized[0 : len(er.windowResized)-1]
			return nil
		}
	}
	return errors.New("trying to unregister an non existing event listener")
}

func (er *eventRegistry) RegisterDocumentCreated(callback func(a wicore.Document)) wicore.EventID {
	er.lock.Lock()
	defer er.lock.Unlock()
	i := er.nextID
	er.nextID++
	if er.documentCreated == nil {
		er.documentCreated = make([]eventDocumentCreated, 0, 10)
	}
	er.documentCreated = append(er.documentCreated, eventDocumentCreated{i, callback})
	return i
}

func (er *eventRegistry) onDocumentCreated(a wicore.Document) {
	items := func() []func(a wicore.Document) {
		er.lock.Lock()
		defer er.lock.Unlock()
		items := make([]func(a wicore.Document), 0, len(er.documentCreated))
		for _, item := range er.documentCreated {
			items = append(items, item.callback)
		}
		return items
	}()
	for _, item := range items {
		item(a)
	}
}

func (er *eventRegistry) RegisterDocumentCursorMoved(callback func(a wicore.Document)) wicore.EventID {
	er.lock.Lock()
	defer er.lock.Unlock()
	i := er.nextID
	er.nextID++
	if er.documentCursorMoved == nil {
		er.documentCursorMoved = make([]eventDocumentCursorMoved, 0, 10)
	}
	er.documentCursorMoved = append(er.documentCursorMoved, eventDocumentCursorMoved{i, callback})
	return i
}

func (er *eventRegistry) onDocumentCursorMoved(a wicore.Document) {
	items := func() []func(a wicore.Document) {
		er.lock.Lock()
		defer er.lock.Unlock()
		items := make([]func(a wicore.Document), 0, len(er.documentCursorMoved))
		for _, item := range er.documentCursorMoved {
			items = append(items, item.callback)
		}
		return items
	}()
	for _, item := range items {
		item(a)
	}
}

func (er *eventRegistry) RegisterTerminalKeyPressed(callback func(a key.Press)) wicore.EventID {
	er.lock.Lock()
	defer er.lock.Unlock()
	i := er.nextID
	er.nextID++
	if er.terminalKeyPressed == nil {
		er.terminalKeyPressed = make([]eventTerminalKeyPressed, 0, 10)
	}
	er.terminalKeyPressed = append(er.terminalKeyPressed, eventTerminalKeyPressed{i, callback})
	return i
}

func (er *eventRegistry) onTerminalKeyPressed(a key.Press) {
	items := func() []func(a key.Press) {
		er.lock.Lock()
		defer er.lock.Unlock()
		items := make([]func(a key.Press), 0, len(er.terminalKeyPressed))
		for _, item := range er.terminalKeyPressed {
			items = append(items, item.callback)
		}
		return items
	}()
	for _, item := range items {
		item(a)
	}
}

func (er *eventRegistry) RegisterTerminalResized(callback func()) wicore.EventID {
	er.lock.Lock()
	defer er.lock.Unlock()
	i := er.nextID
	er.nextID++
	if er.terminalResized == nil {
		er.terminalResized = make([]eventTerminalResized, 0, 10)
	}
	er.terminalResized = append(er.terminalResized, eventTerminalResized{i, callback})
	return i
}

func (er *eventRegistry) onTerminalResized() {
	items := func() []func() {
		er.lock.Lock()
		defer er.lock.Unlock()
		items := make([]func(), 0, len(er.terminalResized))
		for _, item := range er.terminalResized {
			items = append(items, item.callback)
		}
		return items
	}()
	for _, item := range items {
		item()
	}
}

func (er *eventRegistry) RegisterViewCreated(callback func(a wicore.View)) wicore.EventID {
	er.lock.Lock()
	defer er.lock.Unlock()
	i := er.nextID
	er.nextID++
	if er.viewCreated == nil {
		er.viewCreated = make([]eventViewCreated, 0, 10)
	}
	er.viewCreated = append(er.viewCreated, eventViewCreated{i, callback})
	return i
}

func (er *eventRegistry) onViewCreated(a wicore.View) {
	items := func() []func(a wicore.View) {
		er.lock.Lock()
		defer er.lock.Unlock()
		items := make([]func(a wicore.View), 0, len(er.viewCreated))
		for _, item := range er.viewCreated {
			items = append(items, item.callback)
		}
		return items
	}()
	for _, item := range items {
		item(a)
	}
}

func (er *eventRegistry) RegisterWindowCreated(callback func(a wicore.Window)) wicore.EventID {
	er.lock.Lock()
	defer er.lock.Unlock()
	i := er.nextID
	er.nextID++
	if er.windowCreated == nil {
		er.windowCreated = make([]eventWindowCreated, 0, 10)
	}
	er.windowCreated = append(er.windowCreated, eventWindowCreated{i, callback})
	return i
}

func (er *eventRegistry) onWindowCreated(a wicore.Window) {
	items := func() []func(a wicore.Window) {
		er.lock.Lock()
		defer er.lock.Unlock()
		items := make([]func(a wicore.Window), 0, len(er.windowCreated))
		for _, item := range er.windowCreated {
			items = append(items, item.callback)
		}
		return items
	}()
	for _, item := range items {
		item(a)
	}
}

func (er *eventRegistry) RegisterWindowResized(callback func(a wicore.Window)) wicore.EventID {
	er.lock.Lock()
	defer er.lock.Unlock()
	i := er.nextID
	er.nextID++
	if er.windowResized == nil {
		er.windowResized = make([]eventWindowResized, 0, 10)
	}
	er.windowResized = append(er.windowResized, eventWindowResized{i, callback})
	return i
}

func (er *eventRegistry) onWindowResized(a wicore.Window) {
	items := func() []func(a wicore.Window) {
		er.lock.Lock()
		defer er.lock.Unlock()
		items := make([]func(a wicore.Window), 0, len(er.windowResized))
		for _, item := range er.windowResized {
			items = append(items, item.callback)
		}
		return items
	}()
	for _, item := range items {
		item(a)
	}
}
